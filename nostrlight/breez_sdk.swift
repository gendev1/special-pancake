// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(breez_sdkFFI)
    import breez_sdkFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_breez_sdk_5a50_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_breez_sdk_5a50_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
(_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
{
    try makeRustCall(callback, errorHandler: { try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
    case CALL_SUCCESS:
        return returnedVal

    case CALL_ERROR:
        throw try errorHandler(callStatus.errorBuf)

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

public protocol BlockingBreezServicesProtocol {
    func start() throws
    func stop() throws
    func sendPayment(bolt11: String, amountSats: UInt64?) throws -> Payment
    func sendSpontaneousPayment(nodeId: String, amountSats: UInt64) throws -> Payment
    func receivePayment(amountSats: UInt64, description: String) throws -> LnInvoice
    func payLnurl(reqData: LnUrlPayRequestData, amountSats: UInt64, comment: String?) throws -> LnUrlPayResult
    func withdrawLnurl(reqData: LnUrlWithdrawRequestData, amountSats: UInt64, description: String?) throws -> LnUrlCallbackStatus
    func lnurlAuth(reqData: LnUrlAuthRequestData) throws -> LnUrlCallbackStatus
    func nodeInfo() throws -> NodeState?
    func listPayments(filter: PaymentTypeFilter, fromTimestamp: Int64?, toTimestamp: Int64?) throws -> [Payment]
    func sweep(toAddress: String, feeRateSatsPerByte: UInt64) throws
    func fetchFiatRates() throws -> [Rate]
    func listFiatCurrencies() throws -> [FiatCurrency]
    func listLsps() throws -> [LspInformation]
    func connectLsp(lspId: String) throws
    func fetchLspInfo(lspId: String) throws -> LspInformation?
    func lspId() throws -> String?
    func closeLspChannels() throws
    func receiveOnchain() throws -> SwapInfo
    func inProgressSwap() throws -> SwapInfo?
    func listRefundables() throws -> [SwapInfo]
    func refund(swapAddress: String, toAddress: String, satPerVbyte: UInt32) throws -> String
    func executeDevCommand(command: String) throws -> String
    func sync() throws
    func recommendedFees() throws -> RecommendedFees
}

public class BlockingBreezServices: BlockingBreezServicesProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_breez_sdk_5a50_BlockingBreezServices_object_free(pointer, $0) }
    }

    public func start() throws {
        try
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_start(self.pointer, $0)
            }
    }

    public func stop() throws {
        try
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_stop(self.pointer, $0)
            }
    }

    public func sendPayment(bolt11: String, amountSats: UInt64?) throws -> Payment {
        return try FfiConverterTypePayment.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_send_payment(self.pointer,
                                                                  FfiConverterString.lower(bolt11),
                                                                  FfiConverterOptionUInt64.lower(amountSats), $0)
            }
        )
    }

    public func sendSpontaneousPayment(nodeId: String, amountSats: UInt64) throws -> Payment {
        return try FfiConverterTypePayment.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_send_spontaneous_payment(self.pointer,
                                                                              FfiConverterString.lower(nodeId),
                                                                              FfiConverterUInt64.lower(amountSats), $0)
            }
        )
    }

    public func receivePayment(amountSats: UInt64, description: String) throws -> LnInvoice {
        return try FfiConverterTypeLnInvoice.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_receive_payment(self.pointer,
                                                                     FfiConverterUInt64.lower(amountSats),
                                                                     FfiConverterString.lower(description), $0)
            }
        )
    }

    public func payLnurl(reqData: LnUrlPayRequestData, amountSats: UInt64, comment: String?) throws -> LnUrlPayResult {
        return try FfiConverterTypeLnUrlPayResult.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_pay_lnurl(self.pointer,
                                                               FfiConverterTypeLnUrlPayRequestData.lower(reqData),
                                                               FfiConverterUInt64.lower(amountSats),
                                                               FfiConverterOptionString.lower(comment), $0)
            }
        )
    }

    public func withdrawLnurl(reqData: LnUrlWithdrawRequestData, amountSats: UInt64, description: String?) throws -> LnUrlCallbackStatus {
        return try FfiConverterTypeLnUrlCallbackStatus.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_withdraw_lnurl(self.pointer,
                                                                    FfiConverterTypeLnUrlWithdrawRequestData.lower(reqData),
                                                                    FfiConverterUInt64.lower(amountSats),
                                                                    FfiConverterOptionString.lower(description), $0)
            }
        )
    }

    public func lnurlAuth(reqData: LnUrlAuthRequestData) throws -> LnUrlCallbackStatus {
        return try FfiConverterTypeLnUrlCallbackStatus.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_lnurl_auth(self.pointer,
                                                                FfiConverterTypeLnUrlAuthRequestData.lower(reqData), $0)
            }
        )
    }

    public func nodeInfo() throws -> NodeState? {
        return try FfiConverterOptionTypeNodeState.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_node_info(self.pointer, $0)
            }
        )
    }

    public func listPayments(filter: PaymentTypeFilter, fromTimestamp: Int64?, toTimestamp: Int64?) throws -> [Payment] {
        return try FfiConverterSequenceTypePayment.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_list_payments(self.pointer,
                                                                   FfiConverterTypePaymentTypeFilter.lower(filter),
                                                                   FfiConverterOptionInt64.lower(fromTimestamp),
                                                                   FfiConverterOptionInt64.lower(toTimestamp), $0)
            }
        )
    }

    public func sweep(toAddress: String, feeRateSatsPerByte: UInt64) throws {
        try
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_sweep(self.pointer,
                                                           FfiConverterString.lower(toAddress),
                                                           FfiConverterUInt64.lower(feeRateSatsPerByte), $0)
            }
    }

    public func fetchFiatRates() throws -> [Rate] {
        return try FfiConverterSequenceTypeRate.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_fetch_fiat_rates(self.pointer, $0)
            }
        )
    }

    public func listFiatCurrencies() throws -> [FiatCurrency] {
        return try FfiConverterSequenceTypeFiatCurrency.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_list_fiat_currencies(self.pointer, $0)
            }
        )
    }

    public func listLsps() throws -> [LspInformation] {
        return try FfiConverterSequenceTypeLspInformation.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_list_lsps(self.pointer, $0)
            }
        )
    }

    public func connectLsp(lspId: String) throws {
        try
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_connect_lsp(self.pointer,
                                                                 FfiConverterString.lower(lspId), $0)
            }
    }

    public func fetchLspInfo(lspId: String) throws -> LspInformation? {
        return try FfiConverterOptionTypeLspInformation.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_fetch_lsp_info(self.pointer,
                                                                    FfiConverterString.lower(lspId), $0)
            }
        )
    }

    public func lspId() throws -> String? {
        return try FfiConverterOptionString.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_lsp_id(self.pointer, $0)
            }
        )
    }

    public func closeLspChannels() throws {
        try
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_close_lsp_channels(self.pointer, $0)
            }
    }

    public func receiveOnchain() throws -> SwapInfo {
        return try FfiConverterTypeSwapInfo.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_receive_onchain(self.pointer, $0)
            }
        )
    }

    public func inProgressSwap() throws -> SwapInfo? {
        return try FfiConverterOptionTypeSwapInfo.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_in_progress_swap(self.pointer, $0)
            }
        )
    }

    public func listRefundables() throws -> [SwapInfo] {
        return try FfiConverterSequenceTypeSwapInfo.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_list_refundables(self.pointer, $0)
            }
        )
    }

    public func refund(swapAddress: String, toAddress: String, satPerVbyte: UInt32) throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_refund(self.pointer,
                                                            FfiConverterString.lower(swapAddress),
                                                            FfiConverterString.lower(toAddress),
                                                            FfiConverterUInt32.lower(satPerVbyte), $0)
            }
        )
    }

    public func executeDevCommand(command: String) throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_execute_dev_command(self.pointer,
                                                                         FfiConverterString.lower(command), $0)
            }
        )
    }

    public func sync() throws {
        try
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_sync(self.pointer, $0)
            }
    }

    public func recommendedFees() throws -> RecommendedFees {
        return try FfiConverterTypeRecommendedFees.lift(
            rustCallWithError(FfiConverterTypeSdkError.self) {
                breez_sdk_5a50_BlockingBreezServices_recommended_fees(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeBlockingBreezServices: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BlockingBreezServices

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockingBreezServices {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BlockingBreezServices, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BlockingBreezServices {
        return BlockingBreezServices(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BlockingBreezServices) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public struct AesSuccessActionDataDecrypted {
    public var description: String
    public var plaintext: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(description: String, plaintext: String) {
        self.description = description
        self.plaintext = plaintext
    }
}

extension AesSuccessActionDataDecrypted: Equatable, Hashable {
    public static func == (lhs: AesSuccessActionDataDecrypted, rhs: AesSuccessActionDataDecrypted) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.plaintext != rhs.plaintext {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(plaintext)
    }
}

public struct FfiConverterTypeAesSuccessActionDataDecrypted: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesSuccessActionDataDecrypted {
        return try AesSuccessActionDataDecrypted(
            description: FfiConverterString.read(from: &buf),
            plaintext: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AesSuccessActionDataDecrypted, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.plaintext, into: &buf)
    }
}

public struct BitcoinAddressData {
    public var address: String
    public var network: Network
    public var amountSat: UInt64?
    public var label: String?
    public var message: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, network: Network, amountSat: UInt64?, label: String?, message: String?) {
        self.address = address
        self.network = network
        self.amountSat = amountSat
        self.label = label
        self.message = message
    }
}

extension BitcoinAddressData: Equatable, Hashable {
    public static func == (lhs: BitcoinAddressData, rhs: BitcoinAddressData) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.amountSat != rhs.amountSat {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(network)
        hasher.combine(amountSat)
        hasher.combine(label)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeBitcoinAddressData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinAddressData {
        return try BitcoinAddressData(
            address: FfiConverterString.read(from: &buf),
            network: FfiConverterTypeNetwork.read(from: &buf),
            amountSat: FfiConverterOptionUInt64.read(from: &buf),
            label: FfiConverterOptionString.read(from: &buf),
            message: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: BitcoinAddressData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterOptionUInt64.write(value.amountSat, into: &buf)
        FfiConverterOptionString.write(value.label, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
    }
}

public struct ClosedChannelPaymentDetails {
    public var shortChannelId: String
    public var state: ChannelState
    public var fundingTxid: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(shortChannelId: String, state: ChannelState, fundingTxid: String) {
        self.shortChannelId = shortChannelId
        self.state = state
        self.fundingTxid = fundingTxid
    }
}

extension ClosedChannelPaymentDetails: Equatable, Hashable {
    public static func == (lhs: ClosedChannelPaymentDetails, rhs: ClosedChannelPaymentDetails) -> Bool {
        if lhs.shortChannelId != rhs.shortChannelId {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        if lhs.fundingTxid != rhs.fundingTxid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(shortChannelId)
        hasher.combine(state)
        hasher.combine(fundingTxid)
    }
}

public struct FfiConverterTypeClosedChannelPaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClosedChannelPaymentDetails {
        return try ClosedChannelPaymentDetails(
            shortChannelId: FfiConverterString.read(from: &buf),
            state: FfiConverterTypeChannelState.read(from: &buf),
            fundingTxid: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ClosedChannelPaymentDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.shortChannelId, into: &buf)
        FfiConverterTypeChannelState.write(value.state, into: &buf)
        FfiConverterString.write(value.fundingTxid, into: &buf)
    }
}

public struct Config {
    public var breezserver: String
    public var mempoolspaceUrl: String
    public var workingDir: String
    public var network: Network
    public var paymentTimeoutSec: UInt32
    public var defaultLspId: String?
    public var apiKey: String?
    public var maxfeeSat: UInt64?
    public var maxfeepercent: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(breezserver: String, mempoolspaceUrl: String, workingDir: String, network: Network, paymentTimeoutSec: UInt32, defaultLspId: String?, apiKey: String?, maxfeeSat: UInt64?, maxfeepercent: Double) {
        self.breezserver = breezserver
        self.mempoolspaceUrl = mempoolspaceUrl
        self.workingDir = workingDir
        self.network = network
        self.paymentTimeoutSec = paymentTimeoutSec
        self.defaultLspId = defaultLspId
        self.apiKey = apiKey
        self.maxfeeSat = maxfeeSat
        self.maxfeepercent = maxfeepercent
    }
}

extension Config: Equatable, Hashable {
    public static func == (lhs: Config, rhs: Config) -> Bool {
        if lhs.breezserver != rhs.breezserver {
            return false
        }
        if lhs.mempoolspaceUrl != rhs.mempoolspaceUrl {
            return false
        }
        if lhs.workingDir != rhs.workingDir {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.paymentTimeoutSec != rhs.paymentTimeoutSec {
            return false
        }
        if lhs.defaultLspId != rhs.defaultLspId {
            return false
        }
        if lhs.apiKey != rhs.apiKey {
            return false
        }
        if lhs.maxfeeSat != rhs.maxfeeSat {
            return false
        }
        if lhs.maxfeepercent != rhs.maxfeepercent {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(breezserver)
        hasher.combine(mempoolspaceUrl)
        hasher.combine(workingDir)
        hasher.combine(network)
        hasher.combine(paymentTimeoutSec)
        hasher.combine(defaultLspId)
        hasher.combine(apiKey)
        hasher.combine(maxfeeSat)
        hasher.combine(maxfeepercent)
    }
}

public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return try Config(
            breezserver: FfiConverterString.read(from: &buf),
            mempoolspaceUrl: FfiConverterString.read(from: &buf),
            workingDir: FfiConverterString.read(from: &buf),
            network: FfiConverterTypeNetwork.read(from: &buf),
            paymentTimeoutSec: FfiConverterUInt32.read(from: &buf),
            defaultLspId: FfiConverterOptionString.read(from: &buf),
            apiKey: FfiConverterOptionString.read(from: &buf),
            maxfeeSat: FfiConverterOptionUInt64.read(from: &buf),
            maxfeepercent: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterString.write(value.breezserver, into: &buf)
        FfiConverterString.write(value.mempoolspaceUrl, into: &buf)
        FfiConverterString.write(value.workingDir, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterUInt32.write(value.paymentTimeoutSec, into: &buf)
        FfiConverterOptionString.write(value.defaultLspId, into: &buf)
        FfiConverterOptionString.write(value.apiKey, into: &buf)
        FfiConverterOptionUInt64.write(value.maxfeeSat, into: &buf)
        FfiConverterDouble.write(value.maxfeepercent, into: &buf)
    }
}

public struct CurrencyInfo {
    public var name: String
    public var fractionSize: UInt32
    public var spacing: UInt32?
    public var symbol: Symbol?
    public var uniqSymbol: Symbol?
    public var localizedName: [LocalizedName]?
    public var localeOverrides: [LocaleOverrides]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, fractionSize: UInt32, spacing: UInt32?, symbol: Symbol?, uniqSymbol: Symbol?, localizedName: [LocalizedName]?, localeOverrides: [LocaleOverrides]?) {
        self.name = name
        self.fractionSize = fractionSize
        self.spacing = spacing
        self.symbol = symbol
        self.uniqSymbol = uniqSymbol
        self.localizedName = localizedName
        self.localeOverrides = localeOverrides
    }
}

extension CurrencyInfo: Equatable, Hashable {
    public static func == (lhs: CurrencyInfo, rhs: CurrencyInfo) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.fractionSize != rhs.fractionSize {
            return false
        }
        if lhs.spacing != rhs.spacing {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.uniqSymbol != rhs.uniqSymbol {
            return false
        }
        if lhs.localizedName != rhs.localizedName {
            return false
        }
        if lhs.localeOverrides != rhs.localeOverrides {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(fractionSize)
        hasher.combine(spacing)
        hasher.combine(symbol)
        hasher.combine(uniqSymbol)
        hasher.combine(localizedName)
        hasher.combine(localeOverrides)
    }
}

public struct FfiConverterTypeCurrencyInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CurrencyInfo {
        return try CurrencyInfo(
            name: FfiConverterString.read(from: &buf),
            fractionSize: FfiConverterUInt32.read(from: &buf),
            spacing: FfiConverterOptionUInt32.read(from: &buf),
            symbol: FfiConverterOptionTypeSymbol.read(from: &buf),
            uniqSymbol: FfiConverterOptionTypeSymbol.read(from: &buf),
            localizedName: FfiConverterOptionSequenceTypeLocalizedName.read(from: &buf),
            localeOverrides: FfiConverterOptionSequenceTypeLocaleOverrides.read(from: &buf)
        )
    }

    public static func write(_ value: CurrencyInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterUInt32.write(value.fractionSize, into: &buf)
        FfiConverterOptionUInt32.write(value.spacing, into: &buf)
        FfiConverterOptionTypeSymbol.write(value.symbol, into: &buf)
        FfiConverterOptionTypeSymbol.write(value.uniqSymbol, into: &buf)
        FfiConverterOptionSequenceTypeLocalizedName.write(value.localizedName, into: &buf)
        FfiConverterOptionSequenceTypeLocaleOverrides.write(value.localeOverrides, into: &buf)
    }
}

public struct FiatCurrency {
    public var id: String
    public var info: CurrencyInfo

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, info: CurrencyInfo) {
        self.id = id
        self.info = info
    }
}

extension FiatCurrency: Equatable, Hashable {
    public static func == (lhs: FiatCurrency, rhs: FiatCurrency) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.info != rhs.info {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(info)
    }
}

public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        return try FiatCurrency(
            id: FfiConverterString.read(from: &buf),
            info: FfiConverterTypeCurrencyInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypeCurrencyInfo.write(value.info, into: &buf)
    }
}

public struct GreenlightCredentials {
    public var deviceKey: [UInt8]
    public var deviceCert: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deviceKey: [UInt8], deviceCert: [UInt8]) {
        self.deviceKey = deviceKey
        self.deviceCert = deviceCert
    }
}

extension GreenlightCredentials: Equatable, Hashable {
    public static func == (lhs: GreenlightCredentials, rhs: GreenlightCredentials) -> Bool {
        if lhs.deviceKey != rhs.deviceKey {
            return false
        }
        if lhs.deviceCert != rhs.deviceCert {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deviceKey)
        hasher.combine(deviceCert)
    }
}

public struct FfiConverterTypeGreenlightCredentials: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GreenlightCredentials {
        return try GreenlightCredentials(
            deviceKey: FfiConverterSequenceUInt8.read(from: &buf),
            deviceCert: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: GreenlightCredentials, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.deviceKey, into: &buf)
        FfiConverterSequenceUInt8.write(value.deviceCert, into: &buf)
    }
}

public struct InvoicePaidDetails {
    public var paymentHash: String
    public var bolt11: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentHash: String, bolt11: String) {
        self.paymentHash = paymentHash
        self.bolt11 = bolt11
    }
}

extension InvoicePaidDetails: Equatable, Hashable {
    public static func == (lhs: InvoicePaidDetails, rhs: InvoicePaidDetails) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.bolt11 != rhs.bolt11 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(bolt11)
    }
}

public struct FfiConverterTypeInvoicePaidDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvoicePaidDetails {
        return try InvoicePaidDetails(
            paymentHash: FfiConverterString.read(from: &buf),
            bolt11: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: InvoicePaidDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterString.write(value.bolt11, into: &buf)
    }
}

public struct LnInvoice {
    public var bolt11: String
    public var payeePubkey: String
    public var paymentHash: String
    public var description: String?
    public var descriptionHash: String?
    public var amountMsat: UInt64?
    public var timestamp: UInt64
    public var expiry: UInt64
    public var routingHints: [RouteHint]
    public var paymentSecret: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bolt11: String, payeePubkey: String, paymentHash: String, description: String?, descriptionHash: String?, amountMsat: UInt64?, timestamp: UInt64, expiry: UInt64, routingHints: [RouteHint], paymentSecret: [UInt8]) {
        self.bolt11 = bolt11
        self.payeePubkey = payeePubkey
        self.paymentHash = paymentHash
        self.description = description
        self.descriptionHash = descriptionHash
        self.amountMsat = amountMsat
        self.timestamp = timestamp
        self.expiry = expiry
        self.routingHints = routingHints
        self.paymentSecret = paymentSecret
    }
}

extension LnInvoice: Equatable, Hashable {
    public static func == (lhs: LnInvoice, rhs: LnInvoice) -> Bool {
        if lhs.bolt11 != rhs.bolt11 {
            return false
        }
        if lhs.payeePubkey != rhs.payeePubkey {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.descriptionHash != rhs.descriptionHash {
            return false
        }
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.expiry != rhs.expiry {
            return false
        }
        if lhs.routingHints != rhs.routingHints {
            return false
        }
        if lhs.paymentSecret != rhs.paymentSecret {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bolt11)
        hasher.combine(payeePubkey)
        hasher.combine(paymentHash)
        hasher.combine(description)
        hasher.combine(descriptionHash)
        hasher.combine(amountMsat)
        hasher.combine(timestamp)
        hasher.combine(expiry)
        hasher.combine(routingHints)
        hasher.combine(paymentSecret)
    }
}

public struct FfiConverterTypeLnInvoice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnInvoice {
        return try LnInvoice(
            bolt11: FfiConverterString.read(from: &buf),
            payeePubkey: FfiConverterString.read(from: &buf),
            paymentHash: FfiConverterString.read(from: &buf),
            description: FfiConverterOptionString.read(from: &buf),
            descriptionHash: FfiConverterOptionString.read(from: &buf),
            amountMsat: FfiConverterOptionUInt64.read(from: &buf),
            timestamp: FfiConverterUInt64.read(from: &buf),
            expiry: FfiConverterUInt64.read(from: &buf),
            routingHints: FfiConverterSequenceTypeRouteHint.read(from: &buf),
            paymentSecret: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: LnInvoice, into buf: inout [UInt8]) {
        FfiConverterString.write(value.bolt11, into: &buf)
        FfiConverterString.write(value.payeePubkey, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterOptionUInt64.write(value.amountMsat, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
        FfiConverterUInt64.write(value.expiry, into: &buf)
        FfiConverterSequenceTypeRouteHint.write(value.routingHints, into: &buf)
        FfiConverterSequenceUInt8.write(value.paymentSecret, into: &buf)
    }
}

public struct LnPaymentDetails {
    public var paymentHash: String
    public var label: String
    public var destinationPubkey: String
    public var paymentPreimage: String
    public var keysend: Bool
    public var bolt11: String
    public var lnurlSuccessAction: SuccessActionProcessed?
    public var lnurlMetadata: String?
    public var lnAddress: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentHash: String, label: String, destinationPubkey: String, paymentPreimage: String, keysend: Bool, bolt11: String, lnurlSuccessAction: SuccessActionProcessed?, lnurlMetadata: String?, lnAddress: String?) {
        self.paymentHash = paymentHash
        self.label = label
        self.destinationPubkey = destinationPubkey
        self.paymentPreimage = paymentPreimage
        self.keysend = keysend
        self.bolt11 = bolt11
        self.lnurlSuccessAction = lnurlSuccessAction
        self.lnurlMetadata = lnurlMetadata
        self.lnAddress = lnAddress
    }
}

extension LnPaymentDetails: Equatable, Hashable {
    public static func == (lhs: LnPaymentDetails, rhs: LnPaymentDetails) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.destinationPubkey != rhs.destinationPubkey {
            return false
        }
        if lhs.paymentPreimage != rhs.paymentPreimage {
            return false
        }
        if lhs.keysend != rhs.keysend {
            return false
        }
        if lhs.bolt11 != rhs.bolt11 {
            return false
        }
        if lhs.lnurlSuccessAction != rhs.lnurlSuccessAction {
            return false
        }
        if lhs.lnurlMetadata != rhs.lnurlMetadata {
            return false
        }
        if lhs.lnAddress != rhs.lnAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(label)
        hasher.combine(destinationPubkey)
        hasher.combine(paymentPreimage)
        hasher.combine(keysend)
        hasher.combine(bolt11)
        hasher.combine(lnurlSuccessAction)
        hasher.combine(lnurlMetadata)
        hasher.combine(lnAddress)
    }
}

public struct FfiConverterTypeLnPaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnPaymentDetails {
        return try LnPaymentDetails(
            paymentHash: FfiConverterString.read(from: &buf),
            label: FfiConverterString.read(from: &buf),
            destinationPubkey: FfiConverterString.read(from: &buf),
            paymentPreimage: FfiConverterString.read(from: &buf),
            keysend: FfiConverterBool.read(from: &buf),
            bolt11: FfiConverterString.read(from: &buf),
            lnurlSuccessAction: FfiConverterOptionTypeSuccessActionProcessed.read(from: &buf),
            lnurlMetadata: FfiConverterOptionString.read(from: &buf),
            lnAddress: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnPaymentDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
        FfiConverterString.write(value.destinationPubkey, into: &buf)
        FfiConverterString.write(value.paymentPreimage, into: &buf)
        FfiConverterBool.write(value.keysend, into: &buf)
        FfiConverterString.write(value.bolt11, into: &buf)
        FfiConverterOptionTypeSuccessActionProcessed.write(value.lnurlSuccessAction, into: &buf)
        FfiConverterOptionString.write(value.lnurlMetadata, into: &buf)
        FfiConverterOptionString.write(value.lnAddress, into: &buf)
    }
}

public struct LnUrlAuthRequestData {
    public var k1: String
    public var action: String?
    public var domain: String
    public var url: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(k1: String, action: String?, domain: String, url: String) {
        self.k1 = k1
        self.action = action
        self.domain = domain
        self.url = url
    }
}

extension LnUrlAuthRequestData: Equatable, Hashable {
    public static func == (lhs: LnUrlAuthRequestData, rhs: LnUrlAuthRequestData) -> Bool {
        if lhs.k1 != rhs.k1 {
            return false
        }
        if lhs.action != rhs.action {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(k1)
        hasher.combine(action)
        hasher.combine(domain)
        hasher.combine(url)
    }
}

public struct FfiConverterTypeLnUrlAuthRequestData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlAuthRequestData {
        return try LnUrlAuthRequestData(
            k1: FfiConverterString.read(from: &buf),
            action: FfiConverterOptionString.read(from: &buf),
            domain: FfiConverterString.read(from: &buf),
            url: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlAuthRequestData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.k1, into: &buf)
        FfiConverterOptionString.write(value.action, into: &buf)
        FfiConverterString.write(value.domain, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
    }
}

public struct LnUrlErrorData {
    public var reason: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(reason: String) {
        self.reason = reason
    }
}

extension LnUrlErrorData: Equatable, Hashable {
    public static func == (lhs: LnUrlErrorData, rhs: LnUrlErrorData) -> Bool {
        if lhs.reason != rhs.reason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(reason)
    }
}

public struct FfiConverterTypeLnUrlErrorData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlErrorData {
        return try LnUrlErrorData(
            reason: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlErrorData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.reason, into: &buf)
    }
}

public struct LnUrlPayRequestData {
    public var callback: String
    public var minSendable: UInt64
    public var maxSendable: UInt64
    public var metadataStr: String
    public var commentAllowed: UInt16
    public var domain: String
    public var lnAddress: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(callback: String, minSendable: UInt64, maxSendable: UInt64, metadataStr: String, commentAllowed: UInt16, domain: String, lnAddress: String?) {
        self.callback = callback
        self.minSendable = minSendable
        self.maxSendable = maxSendable
        self.metadataStr = metadataStr
        self.commentAllowed = commentAllowed
        self.domain = domain
        self.lnAddress = lnAddress
    }
}

extension LnUrlPayRequestData: Equatable, Hashable {
    public static func == (lhs: LnUrlPayRequestData, rhs: LnUrlPayRequestData) -> Bool {
        if lhs.callback != rhs.callback {
            return false
        }
        if lhs.minSendable != rhs.minSendable {
            return false
        }
        if lhs.maxSendable != rhs.maxSendable {
            return false
        }
        if lhs.metadataStr != rhs.metadataStr {
            return false
        }
        if lhs.commentAllowed != rhs.commentAllowed {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.lnAddress != rhs.lnAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(callback)
        hasher.combine(minSendable)
        hasher.combine(maxSendable)
        hasher.combine(metadataStr)
        hasher.combine(commentAllowed)
        hasher.combine(domain)
        hasher.combine(lnAddress)
    }
}

public struct FfiConverterTypeLnUrlPayRequestData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayRequestData {
        return try LnUrlPayRequestData(
            callback: FfiConverterString.read(from: &buf),
            minSendable: FfiConverterUInt64.read(from: &buf),
            maxSendable: FfiConverterUInt64.read(from: &buf),
            metadataStr: FfiConverterString.read(from: &buf),
            commentAllowed: FfiConverterUInt16.read(from: &buf),
            domain: FfiConverterString.read(from: &buf),
            lnAddress: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlPayRequestData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.callback, into: &buf)
        FfiConverterUInt64.write(value.minSendable, into: &buf)
        FfiConverterUInt64.write(value.maxSendable, into: &buf)
        FfiConverterString.write(value.metadataStr, into: &buf)
        FfiConverterUInt16.write(value.commentAllowed, into: &buf)
        FfiConverterString.write(value.domain, into: &buf)
        FfiConverterOptionString.write(value.lnAddress, into: &buf)
    }
}

public struct LnUrlWithdrawRequestData {
    public var callback: String
    public var k1: String
    public var defaultDescription: String
    public var minWithdrawable: UInt64
    public var maxWithdrawable: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(callback: String, k1: String, defaultDescription: String, minWithdrawable: UInt64, maxWithdrawable: UInt64) {
        self.callback = callback
        self.k1 = k1
        self.defaultDescription = defaultDescription
        self.minWithdrawable = minWithdrawable
        self.maxWithdrawable = maxWithdrawable
    }
}

extension LnUrlWithdrawRequestData: Equatable, Hashable {
    public static func == (lhs: LnUrlWithdrawRequestData, rhs: LnUrlWithdrawRequestData) -> Bool {
        if lhs.callback != rhs.callback {
            return false
        }
        if lhs.k1 != rhs.k1 {
            return false
        }
        if lhs.defaultDescription != rhs.defaultDescription {
            return false
        }
        if lhs.minWithdrawable != rhs.minWithdrawable {
            return false
        }
        if lhs.maxWithdrawable != rhs.maxWithdrawable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(callback)
        hasher.combine(k1)
        hasher.combine(defaultDescription)
        hasher.combine(minWithdrawable)
        hasher.combine(maxWithdrawable)
    }
}

public struct FfiConverterTypeLnUrlWithdrawRequestData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlWithdrawRequestData {
        return try LnUrlWithdrawRequestData(
            callback: FfiConverterString.read(from: &buf),
            k1: FfiConverterString.read(from: &buf),
            defaultDescription: FfiConverterString.read(from: &buf),
            minWithdrawable: FfiConverterUInt64.read(from: &buf),
            maxWithdrawable: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlWithdrawRequestData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.callback, into: &buf)
        FfiConverterString.write(value.k1, into: &buf)
        FfiConverterString.write(value.defaultDescription, into: &buf)
        FfiConverterUInt64.write(value.minWithdrawable, into: &buf)
        FfiConverterUInt64.write(value.maxWithdrawable, into: &buf)
    }
}

public struct LocaleOverrides {
    public var locale: String
    public var spacing: UInt32?
    public var symbol: Symbol

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(locale: String, spacing: UInt32?, symbol: Symbol) {
        self.locale = locale
        self.spacing = spacing
        self.symbol = symbol
    }
}

extension LocaleOverrides: Equatable, Hashable {
    public static func == (lhs: LocaleOverrides, rhs: LocaleOverrides) -> Bool {
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.spacing != rhs.spacing {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(locale)
        hasher.combine(spacing)
        hasher.combine(symbol)
    }
}

public struct FfiConverterTypeLocaleOverrides: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocaleOverrides {
        return try LocaleOverrides(
            locale: FfiConverterString.read(from: &buf),
            spacing: FfiConverterOptionUInt32.read(from: &buf),
            symbol: FfiConverterTypeSymbol.read(from: &buf)
        )
    }

    public static func write(_ value: LocaleOverrides, into buf: inout [UInt8]) {
        FfiConverterString.write(value.locale, into: &buf)
        FfiConverterOptionUInt32.write(value.spacing, into: &buf)
        FfiConverterTypeSymbol.write(value.symbol, into: &buf)
    }
}

public struct LocalizedName {
    public var locale: String
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(locale: String, name: String) {
        self.locale = locale
        self.name = name
    }
}

extension LocalizedName: Equatable, Hashable {
    public static func == (lhs: LocalizedName, rhs: LocalizedName) -> Bool {
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(locale)
        hasher.combine(name)
    }
}

public struct FfiConverterTypeLocalizedName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalizedName {
        return try LocalizedName(
            locale: FfiConverterString.read(from: &buf),
            name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LocalizedName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.locale, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}

public struct LogEntry {
    public var line: String
    public var level: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(line: String, level: String) {
        self.line = line
        self.level = level
    }
}

extension LogEntry: Equatable, Hashable {
    public static func == (lhs: LogEntry, rhs: LogEntry) -> Bool {
        if lhs.line != rhs.line {
            return false
        }
        if lhs.level != rhs.level {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(line)
        hasher.combine(level)
    }
}

public struct FfiConverterTypeLogEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogEntry {
        return try LogEntry(
            line: FfiConverterString.read(from: &buf),
            level: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LogEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.line, into: &buf)
        FfiConverterString.write(value.level, into: &buf)
    }
}

public struct LspInformation {
    public var id: String
    public var name: String
    public var widgetUrl: String
    public var pubkey: String
    public var host: String
    public var channelCapacity: Int64
    public var targetConf: Int32
    public var baseFeeMsat: Int64
    public var feeRate: Double
    public var timeLockDelta: UInt32
    public var minHtlcMsat: Int64
    public var channelFeePermyriad: Int64
    public var lspPubkey: [UInt8]
    public var maxInactiveDuration: Int64
    public var channelMinimumFeeMsat: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, name: String, widgetUrl: String, pubkey: String, host: String, channelCapacity: Int64, targetConf: Int32, baseFeeMsat: Int64, feeRate: Double, timeLockDelta: UInt32, minHtlcMsat: Int64, channelFeePermyriad: Int64, lspPubkey: [UInt8], maxInactiveDuration: Int64, channelMinimumFeeMsat: Int64) {
        self.id = id
        self.name = name
        self.widgetUrl = widgetUrl
        self.pubkey = pubkey
        self.host = host
        self.channelCapacity = channelCapacity
        self.targetConf = targetConf
        self.baseFeeMsat = baseFeeMsat
        self.feeRate = feeRate
        self.timeLockDelta = timeLockDelta
        self.minHtlcMsat = minHtlcMsat
        self.channelFeePermyriad = channelFeePermyriad
        self.lspPubkey = lspPubkey
        self.maxInactiveDuration = maxInactiveDuration
        self.channelMinimumFeeMsat = channelMinimumFeeMsat
    }
}

extension LspInformation: Equatable, Hashable {
    public static func == (lhs: LspInformation, rhs: LspInformation) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.widgetUrl != rhs.widgetUrl {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.host != rhs.host {
            return false
        }
        if lhs.channelCapacity != rhs.channelCapacity {
            return false
        }
        if lhs.targetConf != rhs.targetConf {
            return false
        }
        if lhs.baseFeeMsat != rhs.baseFeeMsat {
            return false
        }
        if lhs.feeRate != rhs.feeRate {
            return false
        }
        if lhs.timeLockDelta != rhs.timeLockDelta {
            return false
        }
        if lhs.minHtlcMsat != rhs.minHtlcMsat {
            return false
        }
        if lhs.channelFeePermyriad != rhs.channelFeePermyriad {
            return false
        }
        if lhs.lspPubkey != rhs.lspPubkey {
            return false
        }
        if lhs.maxInactiveDuration != rhs.maxInactiveDuration {
            return false
        }
        if lhs.channelMinimumFeeMsat != rhs.channelMinimumFeeMsat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(widgetUrl)
        hasher.combine(pubkey)
        hasher.combine(host)
        hasher.combine(channelCapacity)
        hasher.combine(targetConf)
        hasher.combine(baseFeeMsat)
        hasher.combine(feeRate)
        hasher.combine(timeLockDelta)
        hasher.combine(minHtlcMsat)
        hasher.combine(channelFeePermyriad)
        hasher.combine(lspPubkey)
        hasher.combine(maxInactiveDuration)
        hasher.combine(channelMinimumFeeMsat)
    }
}

public struct FfiConverterTypeLspInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LspInformation {
        return try LspInformation(
            id: FfiConverterString.read(from: &buf),
            name: FfiConverterString.read(from: &buf),
            widgetUrl: FfiConverterString.read(from: &buf),
            pubkey: FfiConverterString.read(from: &buf),
            host: FfiConverterString.read(from: &buf),
            channelCapacity: FfiConverterInt64.read(from: &buf),
            targetConf: FfiConverterInt32.read(from: &buf),
            baseFeeMsat: FfiConverterInt64.read(from: &buf),
            feeRate: FfiConverterDouble.read(from: &buf),
            timeLockDelta: FfiConverterUInt32.read(from: &buf),
            minHtlcMsat: FfiConverterInt64.read(from: &buf),
            channelFeePermyriad: FfiConverterInt64.read(from: &buf),
            lspPubkey: FfiConverterSequenceUInt8.read(from: &buf),
            maxInactiveDuration: FfiConverterInt64.read(from: &buf),
            channelMinimumFeeMsat: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LspInformation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.widgetUrl, into: &buf)
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterString.write(value.host, into: &buf)
        FfiConverterInt64.write(value.channelCapacity, into: &buf)
        FfiConverterInt32.write(value.targetConf, into: &buf)
        FfiConverterInt64.write(value.baseFeeMsat, into: &buf)
        FfiConverterDouble.write(value.feeRate, into: &buf)
        FfiConverterUInt32.write(value.timeLockDelta, into: &buf)
        FfiConverterInt64.write(value.minHtlcMsat, into: &buf)
        FfiConverterInt64.write(value.channelFeePermyriad, into: &buf)
        FfiConverterSequenceUInt8.write(value.lspPubkey, into: &buf)
        FfiConverterInt64.write(value.maxInactiveDuration, into: &buf)
        FfiConverterInt64.write(value.channelMinimumFeeMsat, into: &buf)
    }
}

public struct MessageSuccessActionData {
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: String) {
        self.message = message
    }
}

extension MessageSuccessActionData: Equatable, Hashable {
    public static func == (lhs: MessageSuccessActionData, rhs: MessageSuccessActionData) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
    }
}

public struct FfiConverterTypeMessageSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageSuccessActionData {
        return try MessageSuccessActionData(
            message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MessageSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.message, into: &buf)
    }
}

public struct MetadataItem {
    public var key: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, value: String) {
        self.key = key
        self.value = value
    }
}

extension MetadataItem: Equatable, Hashable {
    public static func == (lhs: MetadataItem, rhs: MetadataItem) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(value)
    }
}

public struct FfiConverterTypeMetadataItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataItem {
        return try MetadataItem(
            key: FfiConverterString.read(from: &buf),
            value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MetadataItem, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}

public struct NodeState {
    public var id: String
    public var blockHeight: UInt32
    public var channelsBalanceMsat: UInt64
    public var onchainBalanceMsat: UInt64
    public var utxos: [UnspentTransactionOutput]
    public var maxPayableMsat: UInt64
    public var maxReceivableMsat: UInt64
    public var maxSinglePaymentAmountMsat: UInt64
    public var maxChanReserveMsats: UInt64
    public var connectedPeers: [String]
    public var inboundLiquidityMsats: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, blockHeight: UInt32, channelsBalanceMsat: UInt64, onchainBalanceMsat: UInt64, utxos: [UnspentTransactionOutput], maxPayableMsat: UInt64, maxReceivableMsat: UInt64, maxSinglePaymentAmountMsat: UInt64, maxChanReserveMsats: UInt64, connectedPeers: [String], inboundLiquidityMsats: UInt64) {
        self.id = id
        self.blockHeight = blockHeight
        self.channelsBalanceMsat = channelsBalanceMsat
        self.onchainBalanceMsat = onchainBalanceMsat
        self.utxos = utxos
        self.maxPayableMsat = maxPayableMsat
        self.maxReceivableMsat = maxReceivableMsat
        self.maxSinglePaymentAmountMsat = maxSinglePaymentAmountMsat
        self.maxChanReserveMsats = maxChanReserveMsats
        self.connectedPeers = connectedPeers
        self.inboundLiquidityMsats = inboundLiquidityMsats
    }
}

extension NodeState: Equatable, Hashable {
    public static func == (lhs: NodeState, rhs: NodeState) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.blockHeight != rhs.blockHeight {
            return false
        }
        if lhs.channelsBalanceMsat != rhs.channelsBalanceMsat {
            return false
        }
        if lhs.onchainBalanceMsat != rhs.onchainBalanceMsat {
            return false
        }
        if lhs.utxos != rhs.utxos {
            return false
        }
        if lhs.maxPayableMsat != rhs.maxPayableMsat {
            return false
        }
        if lhs.maxReceivableMsat != rhs.maxReceivableMsat {
            return false
        }
        if lhs.maxSinglePaymentAmountMsat != rhs.maxSinglePaymentAmountMsat {
            return false
        }
        if lhs.maxChanReserveMsats != rhs.maxChanReserveMsats {
            return false
        }
        if lhs.connectedPeers != rhs.connectedPeers {
            return false
        }
        if lhs.inboundLiquidityMsats != rhs.inboundLiquidityMsats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(blockHeight)
        hasher.combine(channelsBalanceMsat)
        hasher.combine(onchainBalanceMsat)
        hasher.combine(utxos)
        hasher.combine(maxPayableMsat)
        hasher.combine(maxReceivableMsat)
        hasher.combine(maxSinglePaymentAmountMsat)
        hasher.combine(maxChanReserveMsats)
        hasher.combine(connectedPeers)
        hasher.combine(inboundLiquidityMsats)
    }
}

public struct FfiConverterTypeNodeState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeState {
        return try NodeState(
            id: FfiConverterString.read(from: &buf),
            blockHeight: FfiConverterUInt32.read(from: &buf),
            channelsBalanceMsat: FfiConverterUInt64.read(from: &buf),
            onchainBalanceMsat: FfiConverterUInt64.read(from: &buf),
            utxos: FfiConverterSequenceTypeUnspentTransactionOutput.read(from: &buf),
            maxPayableMsat: FfiConverterUInt64.read(from: &buf),
            maxReceivableMsat: FfiConverterUInt64.read(from: &buf),
            maxSinglePaymentAmountMsat: FfiConverterUInt64.read(from: &buf),
            maxChanReserveMsats: FfiConverterUInt64.read(from: &buf),
            connectedPeers: FfiConverterSequenceString.read(from: &buf),
            inboundLiquidityMsats: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: NodeState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterUInt32.write(value.blockHeight, into: &buf)
        FfiConverterUInt64.write(value.channelsBalanceMsat, into: &buf)
        FfiConverterUInt64.write(value.onchainBalanceMsat, into: &buf)
        FfiConverterSequenceTypeUnspentTransactionOutput.write(value.utxos, into: &buf)
        FfiConverterUInt64.write(value.maxPayableMsat, into: &buf)
        FfiConverterUInt64.write(value.maxReceivableMsat, into: &buf)
        FfiConverterUInt64.write(value.maxSinglePaymentAmountMsat, into: &buf)
        FfiConverterUInt64.write(value.maxChanReserveMsats, into: &buf)
        FfiConverterSequenceString.write(value.connectedPeers, into: &buf)
        FfiConverterUInt64.write(value.inboundLiquidityMsats, into: &buf)
    }
}

public struct Payment {
    public var id: String
    public var paymentType: PaymentType
    public var paymentTime: Int64
    public var amountMsat: UInt64
    public var feeMsat: UInt64
    public var pending: Bool
    public var description: String?
    public var details: PaymentDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, paymentType: PaymentType, paymentTime: Int64, amountMsat: UInt64, feeMsat: UInt64, pending: Bool, description: String?, details: PaymentDetails) {
        self.id = id
        self.paymentType = paymentType
        self.paymentTime = paymentTime
        self.amountMsat = amountMsat
        self.feeMsat = feeMsat
        self.pending = pending
        self.description = description
        self.details = details
    }
}

extension Payment: Equatable, Hashable {
    public static func == (lhs: Payment, rhs: Payment) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.paymentType != rhs.paymentType {
            return false
        }
        if lhs.paymentTime != rhs.paymentTime {
            return false
        }
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.feeMsat != rhs.feeMsat {
            return false
        }
        if lhs.pending != rhs.pending {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(paymentType)
        hasher.combine(paymentTime)
        hasher.combine(amountMsat)
        hasher.combine(feeMsat)
        hasher.combine(pending)
        hasher.combine(description)
        hasher.combine(details)
    }
}

public struct FfiConverterTypePayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Payment {
        return try Payment(
            id: FfiConverterString.read(from: &buf),
            paymentType: FfiConverterTypePaymentType.read(from: &buf),
            paymentTime: FfiConverterInt64.read(from: &buf),
            amountMsat: FfiConverterUInt64.read(from: &buf),
            feeMsat: FfiConverterUInt64.read(from: &buf),
            pending: FfiConverterBool.read(from: &buf),
            description: FfiConverterOptionString.read(from: &buf),
            details: FfiConverterTypePaymentDetails.read(from: &buf)
        )
    }

    public static func write(_ value: Payment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypePaymentType.write(value.paymentType, into: &buf)
        FfiConverterInt64.write(value.paymentTime, into: &buf)
        FfiConverterUInt64.write(value.amountMsat, into: &buf)
        FfiConverterUInt64.write(value.feeMsat, into: &buf)
        FfiConverterBool.write(value.pending, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterTypePaymentDetails.write(value.details, into: &buf)
    }
}

public struct PaymentFailedData {
    public var error: String
    public var nodeId: String
    public var invoice: LnInvoice?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(error: String, nodeId: String, invoice: LnInvoice?) {
        self.error = error
        self.nodeId = nodeId
        self.invoice = invoice
    }
}

extension PaymentFailedData: Equatable, Hashable {
    public static func == (lhs: PaymentFailedData, rhs: PaymentFailedData) -> Bool {
        if lhs.error != rhs.error {
            return false
        }
        if lhs.nodeId != rhs.nodeId {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(error)
        hasher.combine(nodeId)
        hasher.combine(invoice)
    }
}

public struct FfiConverterTypePaymentFailedData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentFailedData {
        return try PaymentFailedData(
            error: FfiConverterString.read(from: &buf),
            nodeId: FfiConverterString.read(from: &buf),
            invoice: FfiConverterOptionTypeLnInvoice.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentFailedData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.error, into: &buf)
        FfiConverterString.write(value.nodeId, into: &buf)
        FfiConverterOptionTypeLnInvoice.write(value.invoice, into: &buf)
    }
}

public struct Rate {
    public var coin: String
    public var value: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(coin: String, value: Double) {
        self.coin = coin
        self.value = value
    }
}

extension Rate: Equatable, Hashable {
    public static func == (lhs: Rate, rhs: Rate) -> Bool {
        if lhs.coin != rhs.coin {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(coin)
        hasher.combine(value)
    }
}

public struct FfiConverterTypeRate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Rate {
        return try Rate(
            coin: FfiConverterString.read(from: &buf),
            value: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Rate, into buf: inout [UInt8]) {
        FfiConverterString.write(value.coin, into: &buf)
        FfiConverterDouble.write(value.value, into: &buf)
    }
}

public struct RecommendedFees {
    public var fastestFee: UInt32
    public var halfHourFee: UInt32
    public var hourFee: UInt32
    public var economyFee: UInt32
    public var minimumFee: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fastestFee: UInt32, halfHourFee: UInt32, hourFee: UInt32, economyFee: UInt32, minimumFee: UInt32) {
        self.fastestFee = fastestFee
        self.halfHourFee = halfHourFee
        self.hourFee = hourFee
        self.economyFee = economyFee
        self.minimumFee = minimumFee
    }
}

extension RecommendedFees: Equatable, Hashable {
    public static func == (lhs: RecommendedFees, rhs: RecommendedFees) -> Bool {
        if lhs.fastestFee != rhs.fastestFee {
            return false
        }
        if lhs.halfHourFee != rhs.halfHourFee {
            return false
        }
        if lhs.hourFee != rhs.hourFee {
            return false
        }
        if lhs.economyFee != rhs.economyFee {
            return false
        }
        if lhs.minimumFee != rhs.minimumFee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fastestFee)
        hasher.combine(halfHourFee)
        hasher.combine(hourFee)
        hasher.combine(economyFee)
        hasher.combine(minimumFee)
    }
}

public struct FfiConverterTypeRecommendedFees: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecommendedFees {
        return try RecommendedFees(
            fastestFee: FfiConverterUInt32.read(from: &buf),
            halfHourFee: FfiConverterUInt32.read(from: &buf),
            hourFee: FfiConverterUInt32.read(from: &buf),
            economyFee: FfiConverterUInt32.read(from: &buf),
            minimumFee: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RecommendedFees, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.fastestFee, into: &buf)
        FfiConverterUInt32.write(value.halfHourFee, into: &buf)
        FfiConverterUInt32.write(value.hourFee, into: &buf)
        FfiConverterUInt32.write(value.economyFee, into: &buf)
        FfiConverterUInt32.write(value.minimumFee, into: &buf)
    }
}

public struct RouteHint {
    public var hops: [RouteHintHop]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hops: [RouteHintHop]) {
        self.hops = hops
    }
}

extension RouteHint: Equatable, Hashable {
    public static func == (lhs: RouteHint, rhs: RouteHint) -> Bool {
        if lhs.hops != rhs.hops {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hops)
    }
}

public struct FfiConverterTypeRouteHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RouteHint {
        return try RouteHint(
            hops: FfiConverterSequenceTypeRouteHintHop.read(from: &buf)
        )
    }

    public static func write(_ value: RouteHint, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeRouteHintHop.write(value.hops, into: &buf)
    }
}

public struct RouteHintHop {
    public var srcNodeId: String
    public var shortChannelId: UInt64
    public var feesBaseMsat: UInt32
    public var feesProportionalMillionths: UInt32
    public var cltvExpiryDelta: UInt64
    public var htlcMinimumMsat: UInt64?
    public var htlcMaximumMsat: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(srcNodeId: String, shortChannelId: UInt64, feesBaseMsat: UInt32, feesProportionalMillionths: UInt32, cltvExpiryDelta: UInt64, htlcMinimumMsat: UInt64?, htlcMaximumMsat: UInt64?) {
        self.srcNodeId = srcNodeId
        self.shortChannelId = shortChannelId
        self.feesBaseMsat = feesBaseMsat
        self.feesProportionalMillionths = feesProportionalMillionths
        self.cltvExpiryDelta = cltvExpiryDelta
        self.htlcMinimumMsat = htlcMinimumMsat
        self.htlcMaximumMsat = htlcMaximumMsat
    }
}

extension RouteHintHop: Equatable, Hashable {
    public static func == (lhs: RouteHintHop, rhs: RouteHintHop) -> Bool {
        if lhs.srcNodeId != rhs.srcNodeId {
            return false
        }
        if lhs.shortChannelId != rhs.shortChannelId {
            return false
        }
        if lhs.feesBaseMsat != rhs.feesBaseMsat {
            return false
        }
        if lhs.feesProportionalMillionths != rhs.feesProportionalMillionths {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.htlcMinimumMsat != rhs.htlcMinimumMsat {
            return false
        }
        if lhs.htlcMaximumMsat != rhs.htlcMaximumMsat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(srcNodeId)
        hasher.combine(shortChannelId)
        hasher.combine(feesBaseMsat)
        hasher.combine(feesProportionalMillionths)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(htlcMinimumMsat)
        hasher.combine(htlcMaximumMsat)
    }
}

public struct FfiConverterTypeRouteHintHop: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RouteHintHop {
        return try RouteHintHop(
            srcNodeId: FfiConverterString.read(from: &buf),
            shortChannelId: FfiConverterUInt64.read(from: &buf),
            feesBaseMsat: FfiConverterUInt32.read(from: &buf),
            feesProportionalMillionths: FfiConverterUInt32.read(from: &buf),
            cltvExpiryDelta: FfiConverterUInt64.read(from: &buf),
            htlcMinimumMsat: FfiConverterOptionUInt64.read(from: &buf),
            htlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RouteHintHop, into buf: inout [UInt8]) {
        FfiConverterString.write(value.srcNodeId, into: &buf)
        FfiConverterUInt64.write(value.shortChannelId, into: &buf)
        FfiConverterUInt32.write(value.feesBaseMsat, into: &buf)
        FfiConverterUInt32.write(value.feesProportionalMillionths, into: &buf)
        FfiConverterUInt64.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterOptionUInt64.write(value.htlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.htlcMaximumMsat, into: &buf)
    }
}

public struct SwapInfo {
    public var bitcoinAddress: String
    public var createdAt: Int64
    public var lockHeight: Int64
    public var paymentHash: [UInt8]
    public var preimage: [UInt8]
    public var privateKey: [UInt8]
    public var publicKey: [UInt8]
    public var swapperPublicKey: [UInt8]
    public var script: [UInt8]
    public var bolt11: String?
    public var paidSats: UInt32
    public var unconfirmedSats: UInt32
    public var confirmedSats: UInt32
    public var status: SwapStatus
    public var refundTxIds: [String]
    public var unconfirmedTxIds: [String]
    public var confirmedTxIds: [String]
    public var minAllowedDeposit: Int64
    public var maxAllowedDeposit: Int64
    public var lastRedeemError: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bitcoinAddress: String, createdAt: Int64, lockHeight: Int64, paymentHash: [UInt8], preimage: [UInt8], privateKey: [UInt8], publicKey: [UInt8], swapperPublicKey: [UInt8], script: [UInt8], bolt11: String?, paidSats: UInt32, unconfirmedSats: UInt32, confirmedSats: UInt32, status: SwapStatus, refundTxIds: [String], unconfirmedTxIds: [String], confirmedTxIds: [String], minAllowedDeposit: Int64, maxAllowedDeposit: Int64, lastRedeemError: String?) {
        self.bitcoinAddress = bitcoinAddress
        self.createdAt = createdAt
        self.lockHeight = lockHeight
        self.paymentHash = paymentHash
        self.preimage = preimage
        self.privateKey = privateKey
        self.publicKey = publicKey
        self.swapperPublicKey = swapperPublicKey
        self.script = script
        self.bolt11 = bolt11
        self.paidSats = paidSats
        self.unconfirmedSats = unconfirmedSats
        self.confirmedSats = confirmedSats
        self.status = status
        self.refundTxIds = refundTxIds
        self.unconfirmedTxIds = unconfirmedTxIds
        self.confirmedTxIds = confirmedTxIds
        self.minAllowedDeposit = minAllowedDeposit
        self.maxAllowedDeposit = maxAllowedDeposit
        self.lastRedeemError = lastRedeemError
    }
}

extension SwapInfo: Equatable, Hashable {
    public static func == (lhs: SwapInfo, rhs: SwapInfo) -> Bool {
        if lhs.bitcoinAddress != rhs.bitcoinAddress {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.lockHeight != rhs.lockHeight {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.privateKey != rhs.privateKey {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.swapperPublicKey != rhs.swapperPublicKey {
            return false
        }
        if lhs.script != rhs.script {
            return false
        }
        if lhs.bolt11 != rhs.bolt11 {
            return false
        }
        if lhs.paidSats != rhs.paidSats {
            return false
        }
        if lhs.unconfirmedSats != rhs.unconfirmedSats {
            return false
        }
        if lhs.confirmedSats != rhs.confirmedSats {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.refundTxIds != rhs.refundTxIds {
            return false
        }
        if lhs.unconfirmedTxIds != rhs.unconfirmedTxIds {
            return false
        }
        if lhs.confirmedTxIds != rhs.confirmedTxIds {
            return false
        }
        if lhs.minAllowedDeposit != rhs.minAllowedDeposit {
            return false
        }
        if lhs.maxAllowedDeposit != rhs.maxAllowedDeposit {
            return false
        }
        if lhs.lastRedeemError != rhs.lastRedeemError {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bitcoinAddress)
        hasher.combine(createdAt)
        hasher.combine(lockHeight)
        hasher.combine(paymentHash)
        hasher.combine(preimage)
        hasher.combine(privateKey)
        hasher.combine(publicKey)
        hasher.combine(swapperPublicKey)
        hasher.combine(script)
        hasher.combine(bolt11)
        hasher.combine(paidSats)
        hasher.combine(unconfirmedSats)
        hasher.combine(confirmedSats)
        hasher.combine(status)
        hasher.combine(refundTxIds)
        hasher.combine(unconfirmedTxIds)
        hasher.combine(confirmedTxIds)
        hasher.combine(minAllowedDeposit)
        hasher.combine(maxAllowedDeposit)
        hasher.combine(lastRedeemError)
    }
}

public struct FfiConverterTypeSwapInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwapInfo {
        return try SwapInfo(
            bitcoinAddress: FfiConverterString.read(from: &buf),
            createdAt: FfiConverterInt64.read(from: &buf),
            lockHeight: FfiConverterInt64.read(from: &buf),
            paymentHash: FfiConverterSequenceUInt8.read(from: &buf),
            preimage: FfiConverterSequenceUInt8.read(from: &buf),
            privateKey: FfiConverterSequenceUInt8.read(from: &buf),
            publicKey: FfiConverterSequenceUInt8.read(from: &buf),
            swapperPublicKey: FfiConverterSequenceUInt8.read(from: &buf),
            script: FfiConverterSequenceUInt8.read(from: &buf),
            bolt11: FfiConverterOptionString.read(from: &buf),
            paidSats: FfiConverterUInt32.read(from: &buf),
            unconfirmedSats: FfiConverterUInt32.read(from: &buf),
            confirmedSats: FfiConverterUInt32.read(from: &buf),
            status: FfiConverterTypeSwapStatus.read(from: &buf),
            refundTxIds: FfiConverterSequenceString.read(from: &buf),
            unconfirmedTxIds: FfiConverterSequenceString.read(from: &buf),
            confirmedTxIds: FfiConverterSequenceString.read(from: &buf),
            minAllowedDeposit: FfiConverterInt64.read(from: &buf),
            maxAllowedDeposit: FfiConverterInt64.read(from: &buf),
            lastRedeemError: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SwapInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.bitcoinAddress, into: &buf)
        FfiConverterInt64.write(value.createdAt, into: &buf)
        FfiConverterInt64.write(value.lockHeight, into: &buf)
        FfiConverterSequenceUInt8.write(value.paymentHash, into: &buf)
        FfiConverterSequenceUInt8.write(value.preimage, into: &buf)
        FfiConverterSequenceUInt8.write(value.privateKey, into: &buf)
        FfiConverterSequenceUInt8.write(value.publicKey, into: &buf)
        FfiConverterSequenceUInt8.write(value.swapperPublicKey, into: &buf)
        FfiConverterSequenceUInt8.write(value.script, into: &buf)
        FfiConverterOptionString.write(value.bolt11, into: &buf)
        FfiConverterUInt32.write(value.paidSats, into: &buf)
        FfiConverterUInt32.write(value.unconfirmedSats, into: &buf)
        FfiConverterUInt32.write(value.confirmedSats, into: &buf)
        FfiConverterTypeSwapStatus.write(value.status, into: &buf)
        FfiConverterSequenceString.write(value.refundTxIds, into: &buf)
        FfiConverterSequenceString.write(value.unconfirmedTxIds, into: &buf)
        FfiConverterSequenceString.write(value.confirmedTxIds, into: &buf)
        FfiConverterInt64.write(value.minAllowedDeposit, into: &buf)
        FfiConverterInt64.write(value.maxAllowedDeposit, into: &buf)
        FfiConverterOptionString.write(value.lastRedeemError, into: &buf)
    }
}

public struct Symbol {
    public var grapheme: String?
    public var template: String?
    public var rtl: Bool?
    public var position: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(grapheme: String?, template: String?, rtl: Bool?, position: UInt32?) {
        self.grapheme = grapheme
        self.template = template
        self.rtl = rtl
        self.position = position
    }
}

extension Symbol: Equatable, Hashable {
    public static func == (lhs: Symbol, rhs: Symbol) -> Bool {
        if lhs.grapheme != rhs.grapheme {
            return false
        }
        if lhs.template != rhs.template {
            return false
        }
        if lhs.rtl != rhs.rtl {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(grapheme)
        hasher.combine(template)
        hasher.combine(rtl)
        hasher.combine(position)
    }
}

public struct FfiConverterTypeSymbol: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Symbol {
        return try Symbol(
            grapheme: FfiConverterOptionString.read(from: &buf),
            template: FfiConverterOptionString.read(from: &buf),
            rtl: FfiConverterOptionBool.read(from: &buf),
            position: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Symbol, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.grapheme, into: &buf)
        FfiConverterOptionString.write(value.template, into: &buf)
        FfiConverterOptionBool.write(value.rtl, into: &buf)
        FfiConverterOptionUInt32.write(value.position, into: &buf)
    }
}

public struct UnspentTransactionOutput {
    public var txid: [UInt8]
    public var outnum: UInt32
    public var amountMillisatoshi: UInt64
    public var address: String
    public var reserved: Bool
    public var reservedToBlock: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: [UInt8], outnum: UInt32, amountMillisatoshi: UInt64, address: String, reserved: Bool, reservedToBlock: UInt32) {
        self.txid = txid
        self.outnum = outnum
        self.amountMillisatoshi = amountMillisatoshi
        self.address = address
        self.reserved = reserved
        self.reservedToBlock = reservedToBlock
    }
}

extension UnspentTransactionOutput: Equatable, Hashable {
    public static func == (lhs: UnspentTransactionOutput, rhs: UnspentTransactionOutput) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.outnum != rhs.outnum {
            return false
        }
        if lhs.amountMillisatoshi != rhs.amountMillisatoshi {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.reserved != rhs.reserved {
            return false
        }
        if lhs.reservedToBlock != rhs.reservedToBlock {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(outnum)
        hasher.combine(amountMillisatoshi)
        hasher.combine(address)
        hasher.combine(reserved)
        hasher.combine(reservedToBlock)
    }
}

public struct FfiConverterTypeUnspentTransactionOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnspentTransactionOutput {
        return try UnspentTransactionOutput(
            txid: FfiConverterSequenceUInt8.read(from: &buf),
            outnum: FfiConverterUInt32.read(from: &buf),
            amountMillisatoshi: FfiConverterUInt64.read(from: &buf),
            address: FfiConverterString.read(from: &buf),
            reserved: FfiConverterBool.read(from: &buf),
            reservedToBlock: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: UnspentTransactionOutput, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.outnum, into: &buf)
        FfiConverterUInt64.write(value.amountMillisatoshi, into: &buf)
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterBool.write(value.reserved, into: &buf)
        FfiConverterUInt32.write(value.reservedToBlock, into: &buf)
    }
}

public struct UrlSuccessActionData {
    public var description: String
    public var url: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(description: String, url: String) {
        self.description = description
        self.url = url
    }
}

extension UrlSuccessActionData: Equatable, Hashable {
    public static func == (lhs: UrlSuccessActionData, rhs: UrlSuccessActionData) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(url)
    }
}

public struct FfiConverterTypeUrlSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlSuccessActionData {
        return try UrlSuccessActionData(
            description: FfiConverterString.read(from: &buf),
            url: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UrlSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum BreezEvent {
    case newBlock(block: UInt32)
    case invoicePaid(details: InvoicePaidDetails)
    case synced
    case paymentSucceed(details: Payment)
    case paymentFailed(details: PaymentFailedData)
}

public struct FfiConverterTypeBreezEvent: FfiConverterRustBuffer {
    typealias SwiftType = BreezEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BreezEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .newBlock(
                block: FfiConverterUInt32.read(from: &buf)
            )

        case 2: return try .invoicePaid(
                details: FfiConverterTypeInvoicePaidDetails.read(from: &buf)
            )

        case 3: return .synced

        case 4: return try .paymentSucceed(
                details: FfiConverterTypePayment.read(from: &buf)
            )

        case 5: return try .paymentFailed(
                details: FfiConverterTypePaymentFailedData.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BreezEvent, into buf: inout [UInt8]) {
        switch value {
        case let .newBlock(block):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(block, into: &buf)

        case let .invoicePaid(details):
            writeInt(&buf, Int32(2))
            FfiConverterTypeInvoicePaidDetails.write(details, into: &buf)

        case .synced:
            writeInt(&buf, Int32(3))

        case let .paymentSucceed(details):
            writeInt(&buf, Int32(4))
            FfiConverterTypePayment.write(details, into: &buf)

        case let .paymentFailed(details):
            writeInt(&buf, Int32(5))
            FfiConverterTypePaymentFailedData.write(details, into: &buf)
        }
    }
}

extension BreezEvent: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ChannelState {
    case pendingOpen
    case opened
    case pendingClose
    case closed
}

public struct FfiConverterTypeChannelState: FfiConverterRustBuffer {
    typealias SwiftType = ChannelState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .pendingOpen

        case 2: return .opened

        case 3: return .pendingClose

        case 4: return .closed

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChannelState, into buf: inout [UInt8]) {
        switch value {
        case .pendingOpen:
            writeInt(&buf, Int32(1))

        case .opened:
            writeInt(&buf, Int32(2))

        case .pendingClose:
            writeInt(&buf, Int32(3))

        case .closed:
            writeInt(&buf, Int32(4))
        }
    }
}

extension ChannelState: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EnvironmentType {
    case production
    case staging
}

public struct FfiConverterTypeEnvironmentType: FfiConverterRustBuffer {
    typealias SwiftType = EnvironmentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnvironmentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .production

        case 2: return .staging

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EnvironmentType, into buf: inout [UInt8]) {
        switch value {
        case .production:
            writeInt(&buf, Int32(1))

        case .staging:
            writeInt(&buf, Int32(2))
        }
    }
}

extension EnvironmentType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FeeratePreset {
    case regular
    case economy
    case priority
}

public struct FfiConverterTypeFeeratePreset: FfiConverterRustBuffer {
    typealias SwiftType = FeeratePreset

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeratePreset {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .regular

        case 2: return .economy

        case 3: return .priority

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FeeratePreset, into buf: inout [UInt8]) {
        switch value {
        case .regular:
            writeInt(&buf, Int32(1))

        case .economy:
            writeInt(&buf, Int32(2))

        case .priority:
            writeInt(&buf, Int32(3))
        }
    }
}

extension FeeratePreset: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum InputType {
    case bitcoinAddress(address: BitcoinAddressData)
    case bolt11(invoice: LnInvoice)
    case nodeId(nodeId: String)
    case url(url: String)
    case lnUrlPay(data: LnUrlPayRequestData)
    case lnUrlWithdraw(data: LnUrlWithdrawRequestData)
    case lnUrlAuth(data: LnUrlAuthRequestData)
    case lnUrlError(data: LnUrlErrorData)
}

public struct FfiConverterTypeInputType: FfiConverterRustBuffer {
    typealias SwiftType = InputType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InputType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .bitcoinAddress(
                address: FfiConverterTypeBitcoinAddressData.read(from: &buf)
            )

        case 2: return try .bolt11(
                invoice: FfiConverterTypeLnInvoice.read(from: &buf)
            )

        case 3: return try .nodeId(
                nodeId: FfiConverterString.read(from: &buf)
            )

        case 4: return try .url(
                url: FfiConverterString.read(from: &buf)
            )

        case 5: return try .lnUrlPay(
                data: FfiConverterTypeLnUrlPayRequestData.read(from: &buf)
            )

        case 6: return try .lnUrlWithdraw(
                data: FfiConverterTypeLnUrlWithdrawRequestData.read(from: &buf)
            )

        case 7: return try .lnUrlAuth(
                data: FfiConverterTypeLnUrlAuthRequestData.read(from: &buf)
            )

        case 8: return try .lnUrlError(
                data: FfiConverterTypeLnUrlErrorData.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InputType, into buf: inout [UInt8]) {
        switch value {
        case let .bitcoinAddress(address):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBitcoinAddressData.write(address, into: &buf)

        case let .bolt11(invoice):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnInvoice.write(invoice, into: &buf)

        case let .nodeId(nodeId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(nodeId, into: &buf)

        case let .url(url):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(url, into: &buf)

        case let .lnUrlPay(data):
            writeInt(&buf, Int32(5))
            FfiConverterTypeLnUrlPayRequestData.write(data, into: &buf)

        case let .lnUrlWithdraw(data):
            writeInt(&buf, Int32(6))
            FfiConverterTypeLnUrlWithdrawRequestData.write(data, into: &buf)

        case let .lnUrlAuth(data):
            writeInt(&buf, Int32(7))
            FfiConverterTypeLnUrlAuthRequestData.write(data, into: &buf)

        case let .lnUrlError(data):
            writeInt(&buf, Int32(8))
            FfiConverterTypeLnUrlErrorData.write(data, into: &buf)
        }
    }
}

extension InputType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LnUrlCallbackStatus {
    case ok
    case errorStatus(data: LnUrlErrorData)
}

public struct FfiConverterTypeLnUrlCallbackStatus: FfiConverterRustBuffer {
    typealias SwiftType = LnUrlCallbackStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlCallbackStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .ok

        case 2: return try .errorStatus(
                data: FfiConverterTypeLnUrlErrorData.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnUrlCallbackStatus, into buf: inout [UInt8]) {
        switch value {
        case .ok:
            writeInt(&buf, Int32(1))

        case let .errorStatus(data):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnUrlErrorData.write(data, into: &buf)
        }
    }
}

extension LnUrlCallbackStatus: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LnUrlPayResult {
    case endpointSuccess(data: SuccessActionProcessed?)
    case endpointError(data: LnUrlErrorData)
}

public struct FfiConverterTypeLnUrlPayResult: FfiConverterRustBuffer {
    typealias SwiftType = LnUrlPayResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .endpointSuccess(
                data: FfiConverterOptionTypeSuccessActionProcessed.read(from: &buf)
            )

        case 2: return try .endpointError(
                data: FfiConverterTypeLnUrlErrorData.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnUrlPayResult, into buf: inout [UInt8]) {
        switch value {
        case let .endpointSuccess(data):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypeSuccessActionProcessed.write(data, into: &buf)

        case let .endpointError(data):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnUrlErrorData.write(data, into: &buf)
        }
    }
}

extension LnUrlPayResult: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Network {
    case bitcoin
    case testnet
    case signet
    case regtest
}

public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .bitcoin

        case 2: return .testnet

        case 3: return .signet

        case 4: return .regtest

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        case .bitcoin:
            writeInt(&buf, Int32(1))

        case .testnet:
            writeInt(&buf, Int32(2))

        case .signet:
            writeInt(&buf, Int32(3))

        case .regtest:
            writeInt(&buf, Int32(4))
        }
    }
}

extension Network: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentDetails {
    case ln(data: LnPaymentDetails)
    case closedChannel(data: ClosedChannelPaymentDetails)
}

public struct FfiConverterTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .ln(
                data: FfiConverterTypeLnPaymentDetails.read(from: &buf)
            )

        case 2: return try .closedChannel(
                data: FfiConverterTypeClosedChannelPaymentDetails.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentDetails, into buf: inout [UInt8]) {
        switch value {
        case let .ln(data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeLnPaymentDetails.write(data, into: &buf)

        case let .closedChannel(data):
            writeInt(&buf, Int32(2))
            FfiConverterTypeClosedChannelPaymentDetails.write(data, into: &buf)
        }
    }
}

extension PaymentDetails: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentType {
    case sent
    case received
    case closedChannel
}

public struct FfiConverterTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = PaymentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .sent

        case 2: return .received

        case 3: return .closedChannel

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentType, into buf: inout [UInt8]) {
        switch value {
        case .sent:
            writeInt(&buf, Int32(1))

        case .received:
            writeInt(&buf, Int32(2))

        case .closedChannel:
            writeInt(&buf, Int32(3))
        }
    }
}

extension PaymentType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentTypeFilter {
    case sent
    case received
    case all
}

public struct FfiConverterTypePaymentTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = PaymentTypeFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentTypeFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .sent

        case 2: return .received

        case 3: return .all

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentTypeFilter, into buf: inout [UInt8]) {
        switch value {
        case .sent:
            writeInt(&buf, Int32(1))

        case .received:
            writeInt(&buf, Int32(2))

        case .all:
            writeInt(&buf, Int32(3))
        }
    }
}

extension PaymentTypeFilter: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SuccessActionProcessed {
    case aes(data: AesSuccessActionDataDecrypted)
    case message(data: MessageSuccessActionData)
    case url(data: UrlSuccessActionData)
}

public struct FfiConverterTypeSuccessActionProcessed: FfiConverterRustBuffer {
    typealias SwiftType = SuccessActionProcessed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SuccessActionProcessed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .aes(
                data: FfiConverterTypeAesSuccessActionDataDecrypted.read(from: &buf)
            )

        case 2: return try .message(
                data: FfiConverterTypeMessageSuccessActionData.read(from: &buf)
            )

        case 3: return try .url(
                data: FfiConverterTypeUrlSuccessActionData.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SuccessActionProcessed, into buf: inout [UInt8]) {
        switch value {
        case let .aes(data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesSuccessActionDataDecrypted.write(data, into: &buf)

        case let .message(data):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMessageSuccessActionData.write(data, into: &buf)

        case let .url(data):
            writeInt(&buf, Int32(3))
            FfiConverterTypeUrlSuccessActionData.write(data, into: &buf)
        }
    }
}

extension SuccessActionProcessed: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SwapStatus {
    case initial
    case expired
}

public struct FfiConverterTypeSwapStatus: FfiConverterRustBuffer {
    typealias SwiftType = SwapStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwapStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .initial

        case 2: return .expired

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SwapStatus, into buf: inout [UInt8]) {
        switch value {
        case .initial:
            writeInt(&buf, Int32(1))

        case .expired:
            writeInt(&buf, Int32(2))
        }
    }
}

extension SwapStatus: Equatable, Hashable {}

public enum SdkError {
    // Simple error enums only carry a message
    case Error(message: String)
}

public struct FfiConverterTypeSdkError: FfiConverterRustBuffer {
    typealias SwiftType = SdkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .Error(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdkError, into buf: inout [UInt8]) {
        switch value {
        case let .Error(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        }
    }
}

extension SdkError: Equatable, Hashable {}

extension SdkError: Error {}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private typealias UniFFICallbackHandle = UInt64
private class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0

// Declaration and FfiConverters for EventListener Callback Interface

public protocol EventListener: AnyObject {
    func onEvent(e: BreezEvent)
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceEventListener: ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func invokeOnEvent(_ swiftCallbackInterface: EventListener, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            try swiftCallbackInterface.onEvent(
                e: FfiConverterTypeBreezEvent.read(from: &reader)
            )
            return RustBuffer()
            // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }

        let cb: EventListener
        do {
            cb = try FfiConverterCallbackInterfaceEventListener.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("EventListener: Invalid handle")
            return -1
        }

        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceEventListener.drop(handle: handle)
            // No return value.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return 0
        case 1:
            do {
                out_buf.pointee = try invokeOnEvent(cb, args)
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return -1
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return -1
        }
    }

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceEventListener {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_breez_sdk_5a50_EventListener_init_callback(foreignCallbackCallbackInterfaceEventListener, err)
        }
    }

    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<EventListener>()
}

extension FfiConverterCallbackInterfaceEventListener: FfiConverter {
    typealias SwiftType = EventListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

// Declaration and FfiConverters for LogStream Callback Interface

public protocol LogStream: AnyObject {
    func log(l: LogEntry)
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceLogStream: ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func invokeLog(_ swiftCallbackInterface: LogStream, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            try swiftCallbackInterface.log(
                l: FfiConverterTypeLogEntry.read(from: &reader)
            )
            return RustBuffer()
            // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }

        let cb: LogStream
        do {
            cb = try FfiConverterCallbackInterfaceLogStream.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("LogStream: Invalid handle")
            return -1
        }

        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceLogStream.drop(handle: handle)
            // No return value.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return 0
        case 1:
            do {
                out_buf.pointee = try invokeLog(cb, args)
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return -1
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return -1
        }
    }

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceLogStream {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_breez_sdk_5a50_LogStream_init_callback(foreignCallbackCallbackInterfaceLogStream, err)
        }
    }

    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<LogStream>()
}

extension FfiConverterCallbackInterfaceLogStream: FfiConverter {
    typealias SwiftType = LogStream
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

private struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeLnInvoice: FfiConverterRustBuffer {
    typealias SwiftType = LnInvoice?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLnInvoice.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLnInvoice.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeLspInformation: FfiConverterRustBuffer {
    typealias SwiftType = LspInformation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLspInformation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLspInformation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeNodeState: FfiConverterRustBuffer {
    typealias SwiftType = NodeState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSwapInfo: FfiConverterRustBuffer {
    typealias SwiftType = SwapInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSwapInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSwapInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSymbol: FfiConverterRustBuffer {
    typealias SwiftType = Symbol?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSymbol.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSymbol.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSuccessActionProcessed: FfiConverterRustBuffer {
    typealias SwiftType = SuccessActionProcessed?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSuccessActionProcessed.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSuccessActionProcessed.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeLocaleOverrides: FfiConverterRustBuffer {
    typealias SwiftType = [LocaleOverrides]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeLocaleOverrides.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeLocaleOverrides.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeLocalizedName: FfiConverterRustBuffer {
    typealias SwiftType = [LocalizedName]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeLocalizedName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeLocalizedName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = [FiatCurrency]

    public static func write(_ value: [FiatCurrency], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFiatCurrency.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FiatCurrency] {
        let len: Int32 = try readInt(&buf)
        var seq = [FiatCurrency]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFiatCurrency.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeLocaleOverrides: FfiConverterRustBuffer {
    typealias SwiftType = [LocaleOverrides]

    public static func write(_ value: [LocaleOverrides], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocaleOverrides.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocaleOverrides] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocaleOverrides]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeLocaleOverrides.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeLocalizedName: FfiConverterRustBuffer {
    typealias SwiftType = [LocalizedName]

    public static func write(_ value: [LocalizedName], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocalizedName.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocalizedName] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocalizedName]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeLocalizedName.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeLspInformation: FfiConverterRustBuffer {
    typealias SwiftType = [LspInformation]

    public static func write(_ value: [LspInformation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLspInformation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LspInformation] {
        let len: Int32 = try readInt(&buf)
        var seq = [LspInformation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeLspInformation.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePayment: FfiConverterRustBuffer {
    typealias SwiftType = [Payment]

    public static func write(_ value: [Payment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Payment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Payment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePayment.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeRate: FfiConverterRustBuffer {
    typealias SwiftType = [Rate]

    public static func write(_ value: [Rate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Rate] {
        let len: Int32 = try readInt(&buf)
        var seq = [Rate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeRate.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeRouteHint: FfiConverterRustBuffer {
    typealias SwiftType = [RouteHint]

    public static func write(_ value: [RouteHint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRouteHint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RouteHint] {
        let len: Int32 = try readInt(&buf)
        var seq = [RouteHint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeRouteHint.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeRouteHintHop: FfiConverterRustBuffer {
    typealias SwiftType = [RouteHintHop]

    public static func write(_ value: [RouteHintHop], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRouteHintHop.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RouteHintHop] {
        let len: Int32 = try readInt(&buf)
        var seq = [RouteHintHop]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeRouteHintHop.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSwapInfo: FfiConverterRustBuffer {
    typealias SwiftType = [SwapInfo]

    public static func write(_ value: [SwapInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSwapInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SwapInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [SwapInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSwapInfo.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeUnspentTransactionOutput: FfiConverterRustBuffer {
    typealias SwiftType = [UnspentTransactionOutput]

    public static func write(_ value: [UnspentTransactionOutput], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnspentTransactionOutput.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UnspentTransactionOutput] {
        let len: Int32 = try readInt(&buf)
        var seq = [UnspentTransactionOutput]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeUnspentTransactionOutput.read(from: &buf))
        }
        return seq
    }
}

public func registerNode(network: Network, seed: [UInt8]) throws -> GreenlightCredentials {
    return try FfiConverterTypeGreenlightCredentials.lift(
        rustCallWithError(FfiConverterTypeSdkError.self) {
            breez_sdk_5a50_register_node(
                FfiConverterTypeNetwork.lower(network),
                FfiConverterSequenceUInt8.lower(seed), $0
            )
        }
    )
}

public func recoverNode(network: Network, seed: [UInt8]) throws -> GreenlightCredentials {
    return try FfiConverterTypeGreenlightCredentials.lift(
        rustCallWithError(FfiConverterTypeSdkError.self) {
            breez_sdk_5a50_recover_node(
                FfiConverterTypeNetwork.lower(network),
                FfiConverterSequenceUInt8.lower(seed), $0
            )
        }
    )
}

public func initServices(config: Config, seed: [UInt8], creds: GreenlightCredentials, listener: EventListener) throws -> BlockingBreezServices {
    return try FfiConverterTypeBlockingBreezServices.lift(
        rustCallWithError(FfiConverterTypeSdkError.self) {
            breez_sdk_5a50_init_services(
                FfiConverterTypeConfig.lower(config),
                FfiConverterSequenceUInt8.lower(seed),
                FfiConverterTypeGreenlightCredentials.lower(creds),
                FfiConverterCallbackInterfaceEventListener.lower(listener), $0
            )
        }
    )
}

public func setLogStream(logStream: LogStream) throws {
    try

        rustCallWithError(FfiConverterTypeSdkError.self) {
            breez_sdk_5a50_set_log_stream(
                FfiConverterCallbackInterfaceLogStream.lower(logStream), $0
            )
        }
}

public func parseInvoice(invoice: String) throws -> LnInvoice {
    return try FfiConverterTypeLnInvoice.lift(
        rustCallWithError(FfiConverterTypeSdkError.self) {
            breez_sdk_5a50_parse_invoice(
                FfiConverterString.lower(invoice), $0
            )
        }
    )
}

public func parseInput(s: String) throws -> InputType {
    return try FfiConverterTypeInputType.lift(
        rustCallWithError(FfiConverterTypeSdkError.self) {
            breez_sdk_5a50_parse_input(
                FfiConverterString.lower(s), $0
            )
        }
    )
}

public func mnemonicToSeed(phrase: String) throws -> [UInt8] {
    return try FfiConverterSequenceUInt8.lift(
        rustCallWithError(FfiConverterTypeSdkError.self) {
            breez_sdk_5a50_mnemonic_to_seed(
                FfiConverterString.lower(phrase), $0
            )
        }
    )
}

public func defaultConfig(envType: EnvironmentType) -> Config {
    return try! FfiConverterTypeConfig.lift(
        try!

            rustCall {
                breez_sdk_5a50_default_config(
                    FfiConverterTypeEnvironmentType.lower(envType), $0
                )
            }
    )
}

/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum BreezSdkLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {}
}
